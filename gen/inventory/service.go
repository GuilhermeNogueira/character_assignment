// Code generated by goa v3.8.5, DO NOT EDIT.
//
// inventory service
//
// Command:
// $ goa gen characters/design

package inventory

import (
	inventoryviews "characters/gen/inventory/views"
	"context"
)

// Public HTTP frontend
type Service interface {
	// List all items in character inventory
	List(context.Context, *ListPayload) (res StoredInventoryCollection, err error)
	// Show inventory by Id
	// The "view" return value must have one of the following views
	//	- "default"
	//	- "tiny"
	Show(context.Context, *ShowPayload) (res *StoredInventory, view string, err error)
	// Show items in an inventory
	ShowItem(context.Context, *ShowItemPayload) (res StoredItemCollection, err error)
	// Add new inventory and return its ID.
	Add(context.Context, *AddPayload) (res string, err error)
	// Add new item to inventory.
	// The "view" return value must have one of the following views
	//	- "default"
	//	- "tiny"
	AddItem(context.Context, *AddItemPayload) (res *StoredInventory, view string, err error)
	// Remove an item from inventory
	// The "view" return value must have one of the following views
	//	- "default"
	//	- "tiny"
	RemoveItem(context.Context, *RemoveItemPayload) (res *StoredInventory, view string, err error)
	// Remove Inventory
	Remove(context.Context, *RemovePayload) (err error)
}

// ServiceName is the name of the service as defined in the design. This is the
// same value that is set in the endpoint request contexts under the ServiceKey
// key.
const ServiceName = "inventory"

// MethodNames lists the service method names as defined in the design. These
// are the same values that are set in the endpoint request contexts under the
// MethodKey key.
var MethodNames = [7]string{"list", "show", "showItem", "add", "addItem", "removeItem", "remove"}

// AddItemPayload is the payload type of the inventory service addItem method.
type AddItemPayload struct {
	// ID of inventory to add
	ID string
	// ID of item to add
	ItemID string
	// View to render
	View *string
}

// AddPayload is the payload type of the inventory service add method.
type AddPayload struct {
	// ID of character to show
	CharacterID string
}

// ListPayload is the payload type of the inventory service list method.
type ListPayload struct {
	// ID of character to show
	CharacterID string
}

// NotFound is the type returned when attempting to show or delete a resource
// that does not exist.
type NotFound struct {
	// Message of error
	Message string
	// ID of missing resource
	ID string
}

// RemoveItemPayload is the payload type of the inventory service removeItem
// method.
type RemoveItemPayload struct {
	// ID of inventory to add
	ID string
	// ID of item to add
	ItemID string
}

// RemovePayload is the payload type of the inventory service remove method.
type RemovePayload struct {
	// ID of inventory to remove
	ID string
}

// ShowItemPayload is the payload type of the inventory service showItem method.
type ShowItemPayload struct {
	// ID of inventory to show
	ID string
	// View to render
	View *string
}

// ShowPayload is the payload type of the inventory service show method.
type ShowPayload struct {
	// ID of inventory to show
	ID string
	// View to render
	View *string
}

// StoredInventory is the result type of the inventory service show method.
type StoredInventory struct {
	// ID is the unique id of the inventory.
	ID string
	// CharacterId
	CharacterID string
	// Character items
	Items []*StoredItem
}

// StoredInventoryCollection is the result type of the inventory service list
// method.
type StoredInventoryCollection []*StoredInventory

// A StoredItem describes a Item retrieved by the db.
type StoredItem struct {
	// ID is the unique id of the Item.
	ID string
	// Name
	Name string
	// Description
	Description *string
	// Damage
	Damage float64
	// Healing
	Healing float64
	// Protection
	Protection float64
}

// StoredItemCollection is the result type of the inventory service showItem
// method.
type StoredItemCollection []*StoredItem

// Error returns an error description.
func (e *NotFound) Error() string {
	return "NotFound is the type returned when attempting to show or delete a resource that does not exist."
}

// ErrorName returns "NotFound".
func (e *NotFound) ErrorName() string {
	return e.Message
}

// NewStoredInventoryCollection initializes result type
// StoredInventoryCollection from viewed result type StoredInventoryCollection.
func NewStoredInventoryCollection(vres inventoryviews.StoredInventoryCollection) StoredInventoryCollection {
	var res StoredInventoryCollection
	switch vres.View {
	case "default", "":
		res = newStoredInventoryCollection(vres.Projected)
	case "tiny":
		res = newStoredInventoryCollectionTiny(vres.Projected)
	}
	return res
}

// NewViewedStoredInventoryCollection initializes viewed result type
// StoredInventoryCollection from result type StoredInventoryCollection using
// the given view.
func NewViewedStoredInventoryCollection(res StoredInventoryCollection, view string) inventoryviews.StoredInventoryCollection {
	var vres inventoryviews.StoredInventoryCollection
	switch view {
	case "default", "":
		p := newStoredInventoryCollectionView(res)
		vres = inventoryviews.StoredInventoryCollection{Projected: p, View: "default"}
	case "tiny":
		p := newStoredInventoryCollectionViewTiny(res)
		vres = inventoryviews.StoredInventoryCollection{Projected: p, View: "tiny"}
	}
	return vres
}

// NewStoredInventory initializes result type StoredInventory from viewed
// result type StoredInventory.
func NewStoredInventory(vres *inventoryviews.StoredInventory) *StoredInventory {
	var res *StoredInventory
	switch vres.View {
	case "default", "":
		res = newStoredInventory(vres.Projected)
	case "tiny":
		res = newStoredInventoryTiny(vres.Projected)
	}
	return res
}

// NewViewedStoredInventory initializes viewed result type StoredInventory from
// result type StoredInventory using the given view.
func NewViewedStoredInventory(res *StoredInventory, view string) *inventoryviews.StoredInventory {
	var vres *inventoryviews.StoredInventory
	switch view {
	case "default", "":
		p := newStoredInventoryView(res)
		vres = &inventoryviews.StoredInventory{Projected: p, View: "default"}
	case "tiny":
		p := newStoredInventoryViewTiny(res)
		vres = &inventoryviews.StoredInventory{Projected: p, View: "tiny"}
	}
	return vres
}

// NewStoredItemCollection initializes result type StoredItemCollection from
// viewed result type StoredItemCollection.
func NewStoredItemCollection(vres inventoryviews.StoredItemCollection) StoredItemCollection {
	var res StoredItemCollection
	switch vres.View {
	case "default", "":
		res = newStoredItemCollection(vres.Projected)
	case "tiny":
		res = newStoredItemCollectionTiny(vres.Projected)
	}
	return res
}

// NewViewedStoredItemCollection initializes viewed result type
// StoredItemCollection from result type StoredItemCollection using the given
// view.
func NewViewedStoredItemCollection(res StoredItemCollection, view string) inventoryviews.StoredItemCollection {
	var vres inventoryviews.StoredItemCollection
	switch view {
	case "default", "":
		p := newStoredItemCollectionView(res)
		vres = inventoryviews.StoredItemCollection{Projected: p, View: "default"}
	case "tiny":
		p := newStoredItemCollectionViewTiny(res)
		vres = inventoryviews.StoredItemCollection{Projected: p, View: "tiny"}
	}
	return vres
}

// newStoredInventoryCollection converts projected type
// StoredInventoryCollection to service type StoredInventoryCollection.
func newStoredInventoryCollection(vres inventoryviews.StoredInventoryCollectionView) StoredInventoryCollection {
	res := make(StoredInventoryCollection, len(vres))
	for i, n := range vres {
		res[i] = newStoredInventory(n)
	}
	return res
}

// newStoredInventoryCollectionTiny converts projected type
// StoredInventoryCollection to service type StoredInventoryCollection.
func newStoredInventoryCollectionTiny(vres inventoryviews.StoredInventoryCollectionView) StoredInventoryCollection {
	res := make(StoredInventoryCollection, len(vres))
	for i, n := range vres {
		res[i] = newStoredInventoryTiny(n)
	}
	return res
}

// newStoredInventoryCollectionView projects result type
// StoredInventoryCollection to projected type StoredInventoryCollectionView
// using the "default" view.
func newStoredInventoryCollectionView(res StoredInventoryCollection) inventoryviews.StoredInventoryCollectionView {
	vres := make(inventoryviews.StoredInventoryCollectionView, len(res))
	for i, n := range res {
		vres[i] = newStoredInventoryView(n)
	}
	return vres
}

// newStoredInventoryCollectionViewTiny projects result type
// StoredInventoryCollection to projected type StoredInventoryCollectionView
// using the "tiny" view.
func newStoredInventoryCollectionViewTiny(res StoredInventoryCollection) inventoryviews.StoredInventoryCollectionView {
	vres := make(inventoryviews.StoredInventoryCollectionView, len(res))
	for i, n := range res {
		vres[i] = newStoredInventoryViewTiny(n)
	}
	return vres
}

// newStoredInventory converts projected type StoredInventory to service type
// StoredInventory.
func newStoredInventory(vres *inventoryviews.StoredInventoryView) *StoredInventory {
	res := &StoredInventory{}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.CharacterID != nil {
		res.CharacterID = *vres.CharacterID
	}
	if vres.Items != nil {
		res.Items = make([]*StoredItem, len(vres.Items))
		for i, val := range vres.Items {
			res.Items[i] = transformInventoryviewsStoredItemViewToStoredItem(val)
		}
	}
	return res
}

// newStoredInventoryTiny converts projected type StoredInventory to service
// type StoredInventory.
func newStoredInventoryTiny(vres *inventoryviews.StoredInventoryView) *StoredInventory {
	res := &StoredInventory{}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.CharacterID != nil {
		res.CharacterID = *vres.CharacterID
	}
	if vres.Items != nil {
		res.Items = make([]*StoredItem, len(vres.Items))
		for i, val := range vres.Items {
			res.Items[i] = transformInventoryviewsStoredItemViewToStoredItem(val)
		}
	}
	return res
}

// newStoredInventoryView projects result type StoredInventory to projected
// type StoredInventoryView using the "default" view.
func newStoredInventoryView(res *StoredInventory) *inventoryviews.StoredInventoryView {
	vres := &inventoryviews.StoredInventoryView{
		ID:          &res.ID,
		CharacterID: &res.CharacterID,
	}
	if res.Items != nil {
		vres.Items = make([]*inventoryviews.StoredItemView, len(res.Items))
		for i, val := range res.Items {
			vres.Items[i] = transformStoredItemToInventoryviewsStoredItemView(val)
		}
	}
	return vres
}

// newStoredInventoryViewTiny projects result type StoredInventory to projected
// type StoredInventoryView using the "tiny" view.
func newStoredInventoryViewTiny(res *StoredInventory) *inventoryviews.StoredInventoryView {
	vres := &inventoryviews.StoredInventoryView{
		ID:          &res.ID,
		CharacterID: &res.CharacterID,
	}
	if res.Items != nil {
		vres.Items = make([]*inventoryviews.StoredItemView, len(res.Items))
		for i, val := range res.Items {
			vres.Items[i] = transformStoredItemToInventoryviewsStoredItemView(val)
		}
	}
	return vres
}

// newStoredItem converts projected type StoredItem to service type StoredItem.
func newStoredItem(vres *inventoryviews.StoredItemView) *StoredItem {
	res := &StoredItem{
		Description: vres.Description,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Damage != nil {
		res.Damage = *vres.Damage
	}
	if vres.Healing != nil {
		res.Healing = *vres.Healing
	}
	if vres.Protection != nil {
		res.Protection = *vres.Protection
	}
	if vres.Damage == nil {
		res.Damage = 0
	}
	if vres.Healing == nil {
		res.Healing = 0
	}
	if vres.Protection == nil {
		res.Protection = 0
	}
	return res
}

// newStoredItemTiny converts projected type StoredItem to service type
// StoredItem.
func newStoredItemTiny(vres *inventoryviews.StoredItemView) *StoredItem {
	res := &StoredItem{}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Damage != nil {
		res.Damage = *vres.Damage
	}
	if vres.Healing != nil {
		res.Healing = *vres.Healing
	}
	if vres.Protection != nil {
		res.Protection = *vres.Protection
	}
	if vres.Damage == nil {
		res.Damage = 0
	}
	if vres.Healing == nil {
		res.Healing = 0
	}
	if vres.Protection == nil {
		res.Protection = 0
	}
	return res
}

// newStoredItemView projects result type StoredItem to projected type
// StoredItemView using the "default" view.
func newStoredItemView(res *StoredItem) *inventoryviews.StoredItemView {
	vres := &inventoryviews.StoredItemView{
		ID:          &res.ID,
		Name:        &res.Name,
		Description: res.Description,
		Damage:      &res.Damage,
		Healing:     &res.Healing,
		Protection:  &res.Protection,
	}
	return vres
}

// newStoredItemViewTiny projects result type StoredItem to projected type
// StoredItemView using the "tiny" view.
func newStoredItemViewTiny(res *StoredItem) *inventoryviews.StoredItemView {
	vres := &inventoryviews.StoredItemView{
		ID:         &res.ID,
		Name:       &res.Name,
		Damage:     &res.Damage,
		Healing:    &res.Healing,
		Protection: &res.Protection,
	}
	return vres
}

// newStoredItemCollection converts projected type StoredItemCollection to
// service type StoredItemCollection.
func newStoredItemCollection(vres inventoryviews.StoredItemCollectionView) StoredItemCollection {
	res := make(StoredItemCollection, len(vres))
	for i, n := range vres {
		res[i] = newStoredItem(n)
	}
	return res
}

// newStoredItemCollectionTiny converts projected type StoredItemCollection to
// service type StoredItemCollection.
func newStoredItemCollectionTiny(vres inventoryviews.StoredItemCollectionView) StoredItemCollection {
	res := make(StoredItemCollection, len(vres))
	for i, n := range vres {
		res[i] = newStoredItemTiny(n)
	}
	return res
}

// newStoredItemCollectionView projects result type StoredItemCollection to
// projected type StoredItemCollectionView using the "default" view.
func newStoredItemCollectionView(res StoredItemCollection) inventoryviews.StoredItemCollectionView {
	vres := make(inventoryviews.StoredItemCollectionView, len(res))
	for i, n := range res {
		vres[i] = newStoredItemView(n)
	}
	return vres
}

// newStoredItemCollectionViewTiny projects result type StoredItemCollection to
// projected type StoredItemCollectionView using the "tiny" view.
func newStoredItemCollectionViewTiny(res StoredItemCollection) inventoryviews.StoredItemCollectionView {
	vres := make(inventoryviews.StoredItemCollectionView, len(res))
	for i, n := range res {
		vres[i] = newStoredItemViewTiny(n)
	}
	return vres
}

// transformInventoryviewsStoredItemViewToStoredItem builds a value of type
// *StoredItem from a value of type *inventoryviews.StoredItemView.
func transformInventoryviewsStoredItemViewToStoredItem(v *inventoryviews.StoredItemView) *StoredItem {
	if v == nil {
		return nil
	}
	res := &StoredItem{
		ID:          *v.ID,
		Name:        *v.Name,
		Description: v.Description,
		Damage:      *v.Damage,
		Healing:     *v.Healing,
		Protection:  *v.Protection,
	}

	return res
}

// transformStoredItemToInventoryviewsStoredItemView builds a value of type
// *inventoryviews.StoredItemView from a value of type *StoredItem.
func transformStoredItemToInventoryviewsStoredItemView(v *StoredItem) *inventoryviews.StoredItemView {
	if v == nil {
		return nil
	}
	res := &inventoryviews.StoredItemView{
		ID:          &v.ID,
		Name:        &v.Name,
		Description: v.Description,
		Damage:      &v.Damage,
		Healing:     &v.Healing,
		Protection:  &v.Protection,
	}

	return res
}
